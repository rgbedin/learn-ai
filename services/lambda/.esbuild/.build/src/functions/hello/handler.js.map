{
  "version": 3,
  "sources": ["../../../../../src/functions/hello/handler.ts", "../../../../../../../node_modules/@middy/core/index.js", "../../../../../../../node_modules/@middy/util/index.js", "../../../../../../../node_modules/@middy/http-json-body-parser/index.js", "../../../../../../../packages/helpers/middify.ts", "../../../../../../../packages/helpers/response.ts"],
  "sourcesContent": ["import type { APIGatewayProxyResult } from 'aws-lambda';\nimport type { ValidatedAPIGatewayProxyEvent } from 'helpers';\nimport { middyfy, formatJSONResponse } from 'helpers';\n\nimport schema from './schema';\n\nconst hello = async (event: ValidatedAPIGatewayProxyEvent<typeof schema>): Promise<APIGatewayProxyResult> => {\n  await new Promise((res) => setTimeout(res, 500));\n\n  return formatJSONResponse({\n    message: `Hello caraio ! ${event.path}`,\n  });\n};\n\nexport const main = middyfy(hello);\n", "/* global awslambda */ import { Readable } from 'node:stream';\nimport { pipeline } from 'node:stream/promises';\nimport { setTimeout } from 'node:timers/promises';\nconst defaultLambdaHandler = ()=>{};\nconst defaultPlugin = {\n    timeoutEarlyInMillis: 5,\n    timeoutEarlyResponse: ()=>{\n        throw new Error('Timeout');\n    },\n    streamifyResponse: false // Deprecate need for this when AWS provides a flag for when it's looking for it\n};\nconst middy = (lambdaHandler = defaultLambdaHandler, plugin = {})=>{\n    // Allow base handler to be set using .handler()\n    if (typeof lambdaHandler !== 'function') {\n        plugin = lambdaHandler;\n        lambdaHandler = defaultLambdaHandler;\n    }\n    plugin = {\n        ...defaultPlugin,\n        ...plugin\n    };\n    plugin.timeoutEarly = plugin.timeoutEarlyInMillis > 0;\n    plugin.beforePrefetch?.();\n    const beforeMiddlewares = [];\n    const afterMiddlewares = [];\n    const onErrorMiddlewares = [];\n    const middyHandler = (event = {}, context = {})=>{\n        plugin.requestStart?.();\n        const request = {\n            event,\n            context,\n            response: undefined,\n            error: undefined,\n            internal: plugin.internal ?? {}\n        };\n        return runRequest(request, [\n            ...beforeMiddlewares\n        ], lambdaHandler, [\n            ...afterMiddlewares\n        ], [\n            ...onErrorMiddlewares\n        ], plugin);\n    };\n    const middy = plugin.streamifyResponse ? awslambda.streamifyResponse(async (event, responseStream, context)=>{\n        const handlerResponse = await middyHandler(event, context);\n        let handlerBody = handlerResponse;\n        if (handlerResponse.statusCode) {\n            handlerBody = handlerResponse.body ?? '';\n            responseStream = awslambda.HttpResponseStream.from(responseStream, handlerResponse);\n        }\n        // Source @datastream/core (MIT)\n        let handlerStream;\n        if (handlerBody._readableState) {\n            handlerStream = handlerBody;\n        } else if (typeof handlerBody === 'string') {\n            function* iterator(input) {\n                const size = 16384 // 16 * 1024 // Node.js default\n                ;\n                let position = 0;\n                const length = input.length;\n                while(position < length){\n                    yield input.substring(position, position + size);\n                    position += size;\n                }\n            }\n            handlerStream = Readable.from(iterator(handlerBody));\n        }\n        if (!handlerStream) {\n            throw new Error('handler response not a ReadableStream');\n        }\n        await pipeline(handlerStream, responseStream);\n    }) : middyHandler;\n    middy.use = (middlewares)=>{\n        if (!Array.isArray(middlewares)) {\n            middlewares = [\n                middlewares\n            ];\n        }\n        for (const middleware of middlewares){\n            const { before, after, onError } = middleware;\n            if (!before && !after && !onError) {\n                throw new Error('Middleware must be an object containing at least one key among \"before\", \"after\", \"onError\"');\n            }\n            if (before) middy.before(before);\n            if (after) middy.after(after);\n            if (onError) middy.onError(onError);\n        }\n        return middy;\n    };\n    // Inline Middlewares\n    middy.before = (beforeMiddleware)=>{\n        beforeMiddlewares.push(beforeMiddleware);\n        return middy;\n    };\n    middy.after = (afterMiddleware)=>{\n        afterMiddlewares.unshift(afterMiddleware);\n        return middy;\n    };\n    middy.onError = (onErrorMiddleware)=>{\n        onErrorMiddlewares.unshift(onErrorMiddleware);\n        return middy;\n    };\n    middy.handler = (replaceLambdaHandler)=>{\n        lambdaHandler = replaceLambdaHandler;\n        return middy;\n    };\n    return middy;\n};\nconst runRequest = async (request, beforeMiddlewares, lambdaHandler, afterMiddlewares, onErrorMiddlewares, plugin)=>{\n    let timeoutAbort;\n    const timeoutEarly = plugin.timeoutEarly && request.context.getRemainingTimeInMillis // disable when AWS context missing (tests, containers)\n    ;\n    try {\n        await runMiddlewares(request, beforeMiddlewares, plugin);\n        // Check if before stack hasn't exit early\n        if (typeof request.response === 'undefined') {\n            plugin.beforeHandler?.();\n            const handlerAbort = new AbortController();\n            if (timeoutEarly) timeoutAbort = new AbortController();\n            request.response = await Promise.race([\n                lambdaHandler(request.event, request.context, {\n                    signal: handlerAbort.signal\n                }),\n                timeoutEarly ? setTimeout(request.context.getRemainingTimeInMillis() - plugin.timeoutEarlyInMillis, undefined, {\n                    signal: timeoutAbort.signal\n                }).then(()=>{\n                    handlerAbort.abort();\n                    return plugin.timeoutEarlyResponse();\n                }) : Promise.race([])\n            ]);\n            timeoutAbort?.abort() // lambdaHandler may not be a promise\n            ;\n            plugin.afterHandler?.();\n            await runMiddlewares(request, afterMiddlewares, plugin);\n        }\n    } catch (e) {\n        timeoutAbort?.abort() // timeout should be aborted on errors\n        ;\n        // Reset response changes made by after stack before error thrown\n        request.response = undefined;\n        request.error = e;\n        try {\n            await runMiddlewares(request, onErrorMiddlewares, plugin);\n        } catch (e) {\n            // Save error that wasn't handled\n            e.originalError = request.error;\n            request.error = e;\n            throw request.error;\n        }\n        // Catch if onError stack hasn't handled the error\n        if (typeof request.response === 'undefined') throw request.error;\n    } finally{\n        await plugin.requestEnd?.(request);\n    }\n    return request.response;\n};\nconst runMiddlewares = async (request, middlewares, plugin)=>{\n    for (const nextMiddleware of middlewares){\n        plugin.beforeMiddleware?.(nextMiddleware.name);\n        const res = await nextMiddleware(request);\n        plugin.afterMiddleware?.(nextMiddleware.name);\n        // short circuit chaining and respond early\n        if (typeof res !== 'undefined') {\n            request.response = res;\n            return;\n        }\n    }\n};\nexport default middy;\n\n", "export const createPrefetchClient = (options)=>{\n    const { awsClientOptions } = options;\n    const client = new options.AwsClient(awsClientOptions);\n    // AWS XRay\n    if (options.awsClientCapture && options.disablePrefetch) {\n        return options.awsClientCapture(client);\n    } else if (options.awsClientCapture) {\n        console.warn('Unable to apply X-Ray outside of handler invocation scope.');\n    }\n    return client;\n};\nexport const createClient = async (options, request)=>{\n    let awsClientCredentials = {};\n    // Role Credentials\n    if (options.awsClientAssumeRole) {\n        if (!request) {\n            throw new Error('Request required when assuming role');\n        }\n        awsClientCredentials = await getInternal({\n            credentials: options.awsClientAssumeRole\n        }, request);\n    }\n    awsClientCredentials = {\n        ...awsClientCredentials,\n        ...options.awsClientOptions\n    };\n    return createPrefetchClient({\n        ...options,\n        awsClientOptions: awsClientCredentials\n    });\n};\nexport const canPrefetch = (options = {})=>{\n    return !options.awsClientAssumeRole && !options.disablePrefetch;\n};\n// Internal Context\nexport const getInternal = async (variables, request)=>{\n    if (!variables || !request) return {};\n    let keys = [];\n    let values = [];\n    if (variables === true) {\n        keys = values = Object.keys(request.internal);\n    } else if (typeof variables === 'string') {\n        keys = values = [\n            variables\n        ];\n    } else if (Array.isArray(variables)) {\n        keys = values = variables;\n    } else if (typeof variables === 'object') {\n        keys = Object.keys(variables);\n        values = Object.values(variables);\n    }\n    const promises = [];\n    for (const internalKey of values){\n        // 'internal.key.sub_value' -> { [key]: internal.key.sub_value }\n        const pathOptionKey = internalKey.split('.');\n        const rootOptionKey = pathOptionKey.shift();\n        let valuePromise = request.internal[rootOptionKey];\n        if (!isPromise(valuePromise)) {\n            valuePromise = Promise.resolve(valuePromise);\n        }\n        promises.push(valuePromise.then((value)=>pathOptionKey.reduce((p, c)=>p?.[c], value)));\n    }\n    // ensure promise has resolved by the time it's needed\n    // If one of the promises throws it will bubble up to @middy/core\n    values = await Promise.allSettled(promises);\n    const errors = values.filter((res)=>res.status === 'rejected').map((res)=>res.reason);\n    if (errors.length) {\n        throw new Error('Failed to resolve internal values', {\n            cause: errors\n        });\n    }\n    return keys.reduce((obj, key, index)=>({\n            ...obj,\n            [sanitizeKey(key)]: values[index].value\n        }), {});\n};\nconst isPromise = (promise)=>typeof promise?.then === 'function';\nconst sanitizeKeyPrefixLeadingNumber = /^([0-9])/;\nconst sanitizeKeyRemoveDisallowedChar = /[^a-zA-Z0-9]+/g;\nexport const sanitizeKey = (key)=>{\n    return key.replace(sanitizeKeyPrefixLeadingNumber, '_$1').replace(sanitizeKeyRemoveDisallowedChar, '_');\n};\n// fetch Cache\nconst cache = {} // key: { value:{fetchKey:Promise}, expiry }\n;\nexport const processCache = (options, fetch = ()=>undefined, request)=>{\n    let { cacheKey, cacheKeyExpiry, cacheExpiry } = options;\n    cacheExpiry = cacheKeyExpiry?.[cacheKey] ?? cacheExpiry;\n    if (cacheExpiry) {\n        const cached = getCache(cacheKey);\n        const unexpired = cached.expiry && (cacheExpiry < 0 || cached.expiry > Date.now());\n        if (unexpired && cached.modified) {\n            const value = fetch(request, cached.value);\n            cache[cacheKey] = Object.create({\n                value: {\n                    ...cached.value,\n                    ...value\n                },\n                expiry: cached.expiry\n            });\n            return cache[cacheKey];\n        }\n        if (unexpired) {\n            return {\n                ...cached,\n                cache: true\n            };\n        }\n    }\n    const value = fetch(request);\n    const now = Date.now();\n    // secrets-manager overrides to unix timestamp\n    const expiry = cacheExpiry > 86400000 ? cacheExpiry : now + cacheExpiry;\n    const duration = cacheExpiry > 86400000 ? cacheExpiry - now : cacheExpiry;\n    if (cacheExpiry) {\n        const refresh = duration > 0 ? setInterval(()=>processCache(options, fetch, request), duration) : undefined;\n        cache[cacheKey] = {\n            value,\n            expiry,\n            refresh\n        };\n    }\n    return {\n        value,\n        expiry\n    };\n};\nexport const getCache = (key)=>{\n    if (!cache[key]) return {};\n    return cache[key];\n};\n// Used to remove parts of a cache\nexport const modifyCache = (cacheKey, value)=>{\n    if (!cache[cacheKey]) return;\n    clearInterval(cache[cacheKey]?.refresh);\n    cache[cacheKey] = {\n        ...cache[cacheKey],\n        value,\n        modified: true\n    };\n};\nexport const clearCache = (keys = null)=>{\n    keys = keys ?? Object.keys(cache);\n    if (!Array.isArray(keys)) keys = [\n        keys\n    ];\n    for (const cacheKey of keys){\n        clearInterval(cache[cacheKey]?.refresh);\n        cache[cacheKey] = undefined;\n    }\n};\nexport const jsonSafeParse = (text, reviver)=>{\n    if (typeof text !== 'string') return text;\n    const firstChar = text[0];\n    if (firstChar !== '{' && firstChar !== '[' && firstChar !== '\"') return text;\n    try {\n        return JSON.parse(text, reviver);\n    } catch (e) {}\n    return text;\n};\nexport const jsonSafeStringify = (value, replacer, space)=>{\n    try {\n        return JSON.stringify(value, replacer, space);\n    } catch (e) {}\n    return value;\n};\nexport const normalizeHttpResponse = (request)=>{\n    let { response } = request;\n    if (typeof response === 'undefined') {\n        response = {};\n    } else if (typeof response?.statusCode === 'undefined' && typeof response?.body === 'undefined' && typeof response?.headers === 'undefined') {\n        response = {\n            statusCode: 200,\n            body: response\n        };\n    }\n    response.statusCode ??= 500;\n    response.headers ??= {};\n    request.response = response;\n    return response;\n};\nconst createErrorRegexp = /[^a-zA-Z]/g;\nexport class HttpError extends Error {\n    constructor(code, message, options = {}){\n        if (message && typeof message !== 'string') {\n            options = message;\n            message = undefined;\n        }\n        message ??= httpErrorCodes[code];\n        super(message, options);\n        const name = httpErrorCodes[code].replace(createErrorRegexp, '');\n        this.name = name.substr(-5) !== 'Error' ? name + 'Error' : name;\n        this.status = this.statusCode = code // setting `status` for backwards compatibility w/ `http-errors`\n        ;\n        this.expose = options.expose ?? code < 500;\n    }\n}\nexport const createError = (code, message, properties = {})=>{\n    return new HttpError(code, message, properties);\n};\nconst httpErrorCodes = {\n    100: 'Continue',\n    101: 'Switching Protocols',\n    102: 'Processing',\n    103: 'Early Hints',\n    200: 'OK',\n    201: 'Created',\n    202: 'Accepted',\n    203: 'Non-Authoritative Information',\n    204: 'No Content',\n    205: 'Reset Content',\n    206: 'Partial Content',\n    207: 'Multi-Status',\n    208: 'Already Reported',\n    226: 'IM Used',\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Found',\n    303: 'See Other',\n    304: 'Not Modified',\n    305: 'Use Proxy',\n    306: '(Unused)',\n    307: 'Temporary Redirect',\n    308: 'Permanent Redirect',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    405: 'Method Not Allowed',\n    406: 'Not Acceptable',\n    407: 'Proxy Authentication Required',\n    408: 'Request Timeout',\n    409: 'Conflict',\n    410: 'Gone',\n    411: 'Length Required',\n    412: 'Precondition Failed',\n    413: 'Payload Too Large',\n    414: 'URI Too Long',\n    415: 'Unsupported Media Type',\n    416: 'Range Not Satisfiable',\n    417: 'Expectation Failed',\n    418: \"I'm a teapot\",\n    421: 'Misdirected Request',\n    422: 'Unprocessable Entity',\n    423: 'Locked',\n    424: 'Failed Dependency',\n    425: 'Unordered Collection',\n    426: 'Upgrade Required',\n    428: 'Precondition Required',\n    429: 'Too Many Requests',\n    431: 'Request Header Fields Too Large',\n    451: 'Unavailable For Legal Reasons',\n    500: 'Internal Server Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Gateway Timeout',\n    505: 'HTTP Version Not Supported',\n    506: 'Variant Also Negotiates',\n    507: 'Insufficient Storage',\n    508: 'Loop Detected',\n    509: 'Bandwidth Limit Exceeded',\n    510: 'Not Extended',\n    511: 'Network Authentication Required'\n};\n\n", "import { createError } from '@middy/util';\nconst mimePattern = /^application\\/(.+\\+)?json($|;.+)/;\nconst defaults = {\n    reviver: undefined,\n    disableContentTypeError: true\n};\nconst httpJsonBodyParserMiddleware = (opts = {})=>{\n    const options = {\n        ...defaults,\n        ...opts\n    };\n    const httpJsonBodyParserMiddlewareBefore = async (request)=>{\n        const { headers, body } = request.event;\n        const contentType = headers?.['Content-Type'] ?? headers?.['content-type'];\n        if (!mimePattern.test(contentType)) {\n            if (options.disableContentTypeError) {\n                return;\n            }\n            throw createError(415, 'Unsupported Media Type', {\n                cause: contentType\n            });\n        }\n        try {\n            const data = request.event.isBase64Encoded ? Buffer.from(body, 'base64').toString() : body;\n            request.event.body = JSON.parse(data, options.reviver);\n        } catch (cause) {\n            // UnprocessableEntity\n            throw createError(415, 'Invalid or malformed JSON was provided', {\n                cause\n            });\n        }\n    };\n    return {\n        before: httpJsonBodyParserMiddlewareBefore\n    };\n};\nexport default httpJsonBodyParserMiddleware;\n\n", "import middy from \"@middy/core\";\nimport middyJsonBodyParser from \"@middy/http-json-body-parser\";\nimport type { Handler } from \"aws-lambda\";\n\nexport const middyfy = <TEvent, TResult>(handler: Handler<TEvent, TResult>) => {\n  return middy<TEvent, TResult>(handler).use(middyJsonBodyParser());\n};\n", "import type {\n  APIGatewayProxyEvent,\n  APIGatewayProxyResult,\n  Handler,\n} from \"aws-lambda\";\nimport type { FromSchema } from \"json-schema-to-ts\";\n\nexport type ValidatedAPIGatewayProxyEvent<S extends object> = Omit<\n  APIGatewayProxyEvent,\n  \"body\"\n> & { body: FromSchema<S> };\nexport type ValidatedEventAPIGatewayProxyEvent<S extends object> = Handler<\n  ValidatedAPIGatewayProxyEvent<S>,\n  APIGatewayProxyResult\n>;\n\nexport const formatJSONResponse = (response: Record<string, unknown>) => {\n  return {\n    statusCode: 200,\n    body: JSON.stringify(response),\n  };\n};\n"],
  "mappings": "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",
  "names": ["import_promises", "middy", "e"]
}
